# ==== Purpose ====
#
# This test is executed twice for each test case. Before every
# testcase it is run with mysqltest in record mode and will thus
# produce an output file that can be compared to output from after the
# tescase.  In that way, it is possible to check that a testcase does
# not have any unwanted side affects.

--disable_query_log

# We want to ensure all slave configuration is restored.  But SHOW
# SLAVE STATUS returns nothing for servers not configured as slaves,
# and (after BUG#28796 was fixed) there is no way to de-configure a
# slave.  Hence, it's impossible to clean up the replication state at
# the end.  But we want to check that the slave is stopped, there is
# no error, and a few other invariants.  So we issue SHOW SLAVE
# STATUS, and if it returns no rows we fake the result.
--let $tmp= query_get_value(SHOW SLAVE STATUS, Slave_IO_Running, 1)
--let $tmp= `SELECT '$tmp' = 'No such row'`
if ($tmp)
{
  # Note: after WL#5177, fields 13-18 shall not be filtered-out.
  --echo Slave_IO_State	
  --echo Master_Host	127.0.0.1
  --echo Master_User	root
  --echo Master_Port	#
  --echo Connect_Retry	#
  --echo Master_Log_File	#
  --echo Read_Master_Log_Pos	#
  --echo Relay_Log_File	#
  --echo Relay_Log_Pos	#
  --echo Relay_Master_Log_File	#
  --echo Slave_IO_Running	No
  --echo Slave_SQL_Running	No
  --echo Replicate_Do_DB	#
  --echo Replicate_Ignore_DB	#
  --echo Replicate_Do_Table	#
  --echo Replicate_Ignore_Table	#
  --echo Replicate_Wild_Do_Table	#
  --echo Replicate_Wild_Ignore_Table	#
  --echo Last_Errno	0
  --echo Last_Error	
  --echo Skip_Counter	0
  --echo Exec_Master_Log_Pos	#
  --echo Relay_Log_Space	#
  --echo Until_Condition	#
  --echo Until_Log_File	#
  --echo Until_Log_Pos	#
  --echo Master_SSL_Allowed	No
  --echo Master_SSL_CA_File	
  --echo Master_SSL_CA_Path	
  --echo Master_SSL_Cert	
  --echo Master_SSL_Cipher	
  --echo Master_SSL_Key	
  --echo Seconds_Behind_Master	NULL
  --echo Master_SSL_Verify_Server_Cert	No
  --echo Last_IO_Errno	0
  --echo Last_IO_Error	
  --echo Last_SQL_Errno	0
  --echo Last_SQL_Error	
  --echo Replicate_Ignore_Server_Ids	
  --echo Master_Server_Id	#
  --echo Master_SSL_Crl	#
  --echo Master_SSL_Crlpath	#
  --echo Using_Gtid	No
  --echo Gtid_IO_Pos	#
  --echo Replicate_Do_Domain_Ids	
  --echo Replicate_Ignore_Domain_Ids	
  --echo Parallel_Mode	conservative
  --echo SQL_Delay	0
  --echo SQL_Remaining_Delay	NULL
  --echo Slave_SQL_Running_State	
}
if (!$tmp) {
  # Note: after WL#5177, fields 13-18 shall not be filtered-out.
  --replace_column 4 # 5 # 6 # 7 # 8 # 9 # 10 # 13 # 14 # 15 # 16 # 17 # 18 # 22 # 23 # 24 # 25 # 26 # 40 # 41 # 42 # 44 #
  query_vertical
  SHOW SLAVE STATUS;
}

if (`SELECT COUNT(*) = 1 FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME='wsrep_schema'`) {
    if (`SELECT COUNT(*) > 0 FROM wsrep_schema.SR`) {
    --die The wsrep_schema.SR table is not empty at the end of the test
    }
}

--let $mysql_port= `SELECT @@port`
# The state file is used to distinguish whether this execution of
# check-testcase.test is before or after a particular test.
# * If it does not exist, then this is a "before" execution and we create it,
# * If it exists, then this is an "after" execution and we delete it.
--let _STATE_FILE= $MYSQL_TMP_DIR/check_testcase_state_$mysql_port
--let _INC_FILE= $MYSQL_TMP_DIR/check_testcase_state_$mysql_port.inc
--perl
use strict;
my $state_file= $ENV{'_STATE_FILE'};
my $before= 1;
if (-e $state_file) {
  $before= 0;
}
my $fh;
my $inc_file= $ENV{'_INC_FILE'};
if (!open($fh, ">", $inc_file)) {
  die "Unable to open '$inc_file' for writing: $!";
}
print $fh "--let \$before= $before\n";
close $fh;
if ($before) {
  if (!open($fh, ">", $state_file)) {
    die "Unable to open '$state_file' for writing: $!";
  }
  close $fh;
} else {
  if (!unlink($state_file)) {
    die "Unable to delete '$state_file': $!";
  }
}
EOF
--source $_INC_FILE
--remove_file $_INC_FILE
# Now $before is set to 1 if we are executing before the test and 0 if after the test.

call mtr.check_testcase();
#
# Check that SHOW ENGINE INNODB STATUS does not show any active transactions
# We do this only if wsrep provider is loaded, to avoid disturbing any non-Galera MTR tests
#

if (`SELECT @@wsrep_on`) {
  if (`SELECT COUNT(*) FROM information_schema.innodb_trx WHERE trx_mysql_thread_id != 0`) {
    if ($before) {
      --echo Before test start.
    }
    if (!$before) {
      --echo After test end.
    }
    --echo There is one or more active InnoDB transaction(s) when there should be none. Dumping some diagnostics.

    --enable_query_log

    SET GLOBAL innodb_status_output_locks=ON;
    SHOW ENGINE INNODB STATUS;
    SET GLOBAL innodb_status_output_locks=default;

    --vertical_results
    if ($before) {
      --replace_regex /$/ /
    }
    SELECT * FROM information_schema.processlist;

    if ($before) {
      --replace_regex /$/ /
    }
    SELECT * FROM information_schema.innodb_trx;

    if ($before) {
      --replace_regex /$/ /
    }
    SELECT * FROM information_schema.innodb_locks;

    if ($before) {
      --replace_regex /$/ /
    }
    SELECT * FROM information_schema.innodb_lock_waits;
    --horizontal_results
    --disable_query_log
  }
}
let $datadir=`select @@datadir`;
list_files $datadir mysql_upgrade_info;
list_files $datadir/test #sql*;
list_files $datadir/mysql #sql*;

--enable_query_log

